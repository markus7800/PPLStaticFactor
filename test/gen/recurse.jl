
using Gen
using Random

struct ProductionValue
    val::Float64
end
struct ProductionNode
    val::String
end
struct AggregationResult
    val::Float64
end

@gen function production_kernel(production_node::ProductionNode)
    leaf = @trace(bernoulli(0.5), :leaf)
    ix = production_node.val
    if leaf
        return Production(ProductionValue(1), ProductionNode[])
    else
        nodes = ProductionNode[ProductionNode(ix * "A"), ProductionNode(ix * "B")]
        value = ProductionValue(0)
        return Production(value, nodes) # Production(value::V,children::Vector{U})
    end
end


@gen function aggregation_kernel(production_value::ProductionValue, child_outputs::Vector{AggregationResult})::AggregationResult
    return AggregationResult(production_value.val + sum(o.val for o in child_outputs; init=0))
end

recurse_model = Recurse(
    production_kernel,
    aggregation_kernel,
    2, # maximum number of children generated by production
    ProductionNode, # U (passed from production to its children)
    ProductionValue, # V (passed from production to aggregation)
    AggregationResult, # W (passed from aggregation to its parents, also Recurse's return type)
)

# args::Tuple{U,Int} = (root_production_input::U, root_idx::Int)
Random.seed!(0)
tr = simulate(recurse_model, (ProductionNode(""), 1))
get_choices(tr)

get_retval(tr)

@gen function model()
    @trace(recurse_model(ProductionNode(""), 1), :x)
end

Random.seed!(0)
tr = simulate(model, ())

tr[:x]

get_choices(tr)[:x => (6,Val(:production)) => :leaf]

mh(tr, select(:x => (6,Val(:production)) => :leaf))