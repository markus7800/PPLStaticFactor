using Gen
include("lmh.jl")

# this file reimplements the Geometric model with Gen's Recurse construct
# and demonstrates why we cannot apply LMH for such models
# This file is not meant to be run as a script, but rather in an interactive Julia session.

# repeat the original implementation

@gen function geometric(p::Float64)
    i::Int = -1
    b::Bool = true
    while b 
        i = i + 1
        b = {:b => i} ~ bernoulli(p)
    end
    return i
end

struct GeometricLMHSelector <: LMHSelector end
function get_length(::GeometricLMHSelector, trace::Gen.ChoiceMap, args::Tuple, observations::Gen.ChoiceMap)::Int
    return get_length(trace)
end
function get_resample_address(selector::GeometricLMHSelector, trace::Gen.ChoiceMap, args::Tuple, observations::Gen.ChoiceMap)
    total = get_length(selector, trace, args, observations)
    return :b => rand(0:total-1)
end

N = 100_000

model = geometric
args = (0.5,)
observations = choicemap();

selector = GeometricLMHSelector()

acceptance_rate = lmh(10, N ÷ 10, selector, model, args, observations, check=true)
res = @timed lmh(10, N ÷ 10, selector, model, args, observations)
println(@sprintf("Gen time: %.3f μs", res.time / N * 10^6))
println(@sprintf("Acceptance rate: %.2f%%", acceptance_rate*100))

# implement Geometric with Recurse

struct ProductionValue
    val::Int
end
struct ProductionNode
    i::Int
    p::Float64
end
struct AggregationResult
    val::Int
end

@gen function production_kernel(production_node::ProductionNode)
    i = production_node.i
    p = production_node.p
    b ~ bernoulli(production_node.p)
    if b
        return Production(ProductionValue(i), ProductionNode[ProductionNode(i + 1, p)])
    else
        return Production(ProductionValue(i), ProductionNode[])
    end
end

@gen function aggregation_kernel(production_value::ProductionValue, child_outputs::Vector{AggregationResult})::AggregationResult
    if length(child_outputs) > 0
        return AggregationResult(child_outputs[1].val)
    else
        return AggregationResult(production_value.val)
    end
end

recurse_model = Recurse(
    production_kernel,
    aggregation_kernel,
    1, # maximum number of children generated by production
    ProductionNode, # U (passed from production to its children)
    ProductionValue, # V (passed from production to aggregation)
    AggregationResult, # W (passed from aggregation to its parents, also Recurse's return type)
)

@gen function geometric_recurse(p::Float64)
    i ~ recurse_model(ProductionNode(0, p), 0)
    return i.val
end

Random.seed!(0); tr, _ = generate(geometric, args); get_choices(tr)

Random.seed!(0); tr, _ = generate(geometric_recurse, args); get_choices(tr)
tr[:i => (0, Val(:production)) => :b]

# check that both models produce the same distribution
g1 = [get_retval(simulate(geometric_recurse, args)) for _ in 1:10^5];
[sum(g1 .== i) / length(g1) for i in 0:10]

g2 = [get_retval(simulate(geometric, args)) for _ in 1:10^5];
[sum(g2 .== i) / length(g2) for i in 0:10]


struct GeometricRecurseLMHSelector <: LMHSelector end
function get_length(::GeometricRecurseLMHSelector, trace::Gen.ChoiceMap, args::Tuple, observations::Gen.ChoiceMap)::Int
    return get_length(trace)
end
function get_resample_address(selector::GeometricRecurseLMHSelector, trace::Gen.ChoiceMap, args::Tuple, observations::Gen.ChoiceMap)
    total = get_length(selector, trace, args, observations)
    return :i => (rand(0:total-1), Val(:production)) => :b
end

# ERROR: regenerate not implemented for Recurse
acceptance_rate = lmh(10, N ÷ 10, GeometricRecurseLMHSelector(), geometric_recurse, args, observations, check=true)

# There is a second way to implement MH in Gen without using regenerate
# It requires only `update` which is implemented for Recurse
# But we have to write a proposal generative function

struct GeometricRecurseLMHSelector2 <: LMHSelector end
function get_length(::GeometricRecurseLMHSelector2, trace::Gen.ChoiceMap, args::Tuple, observations::Gen.ChoiceMap)::Int
    return get_length(trace)
end
function get_resample_address(selector::GeometricRecurseLMHSelector2, trace::Gen.ChoiceMap, args::Tuple, observations::Gen.ChoiceMap)
    total = get_length(selector, trace, args, observations)
    p = args[1]
    return :i => (rand(0:total-1), Val(:production)) => :b, bernoulli, (p,)
end

@gen function lmh_proposal(trace, resample_address, distribution, dist_args)
    new_value = @trace(distribution(dist_args...), resample_address)
    println("resample_address", resample_address, " change from ", trace[resample_address], " to ", new_value)

end

function lmh_2(N::Int, n_iter::Int, selector::LMHSelector, model, args, observations; check::Bool=false)
    Random.seed!(0)

    n_accepted = 0
    for _ in 1:N
        trace, lp = generate(model, args, observations)
        # println(trace)

        for i in 1:n_iter
            println("Iter $i.")
            choices = get_choices(trace)
            display(choices)
            L = get_length(selector, choices, args, observations)
            resample_address, distribution, dist_args = get_resample_address(selector, choices, args, observations)

            new_trace, accept = mh(trace, lmh_proposal, (resample_address, distribution, dist_args), observations=observations, check=check)
            accept = accept && (rand() < L / get_length(selector, get_choices(new_trace), args, observations))

            if accept
                trace = new_trace
                n_accepted += 1
            end
        end  
    end
    return n_accepted / (n_iter*N)
end

# Error: Assess did not visit the following address
# https://github.com/probcomp/Gen.jl/blob/91d798f2d2f0c175b1be3dc6daf3a10a8acf5da3/src/inference/mh.jl#L37
# If the proposal modifies addresses that determine the control flow in the model, values must be provided by the proposal for any addresses that are newly sampled by the model.
acceptance_rate = lmh_2(10, N ÷ 10, GeometricRecurseLMHSelector2(), geometric_recurse, args, observations, check=true)

# This means in the lmh_proposal we would have to provide values for any addresses that are newly sampled by the model,
# but we do not know these addresses for a general single-site update (without running the actual model). 
# To the best of our understanding, a model specific implementation of LMH would be possible, but not a general-purpose implementation like we want.
